npm run build


何をメインに据えるか
  要素のProceduralな生成
    shape
    material
    movement
  レンダリング
    ComputeShaderが使えないので無理そう

TODO
now:
future:
  random
    PCG (Permuted congruential generator)
  hash
  procedural shape
    Shape同士の論理演算
  procedural material
    normal, metalness, specular, diffuse 等パラメータの揺れ
  いろいろ動かす
    Inverse Kinematics
soooooon:
  ComputeShader
    Monte-carlo ray-trace
    Photon-mapping
    Screen-space effects
  曲率近似AmbientSelfOcclusion
  physics based rendering (material)
  波のGPUシミュレーション
  面光源
    photon.ray.start が random_uniform に従う?
  glslify-loader
  template-literals-loader
  (webasm + spir-v) へのコンパイル
    LLVM-SPIRV-BackendがKhronosから出てる
    Rust-gpuでやりたいな



リファクタリング
  mix(float, float, float) -> mix(float, float, bool)
  GlEntytyからのuniformをstructにする(Transformのみ?)


findNearestDrawable
rayCastのl + obj_distance < EPS となるものは無視?

BoundingShape
複雑な形状の物(content)を簡単な形状の物(bounding)で覆う
普段はboundingとの距離を、boundingとの距離がmargin以下ならcontentとの距離を返す

オブジェクトの重なり
オブジェクトが重なる位置において、どのオブジェクトの情報を返すか
優先度を設定し、自動的にDefferenceを行う?

findMedium
物体から出る(dot(ray.direction,法線)>0)時に使う
距離が負かつ最も大きいもの(絶対値が小さい)ものを媒質とする
今まで居た物質は無視
物体に入る(dot(ray.direction,法線<0))ときは当たった面のものを使えばよい

ray-marching
  反射/屈折後に2*EPSだけ進める?

屈折光のray-marchingどうする?
  距離関数が負のとき
    陰面消去の判定を反転
    距離の符号を反転
  反射するか屈折するかを乱数で



パストレーシング、計算誤差の影響が結構大きい(ray.directionの精度?)


rgb<->hsv

右手系の座標を扱う: cross(x,y) = z

環境光(ambient)
  色も強度も一定
拡散反射(diffuse, ランバート反射)
  photon入射ベクトルと面の法線で決まる
  視線は関係なし
鏡面反射(specular, 鏡面ハイライト-ガウス分布)
  視線と入射ベクトルと面の法線で決まる
  強度変化のみ、色の変化なし

入射光エネルギー = absorption + (1-drain)( metalness + (1-metalness)( (1-transparency) + transparency ) )
  absorption(extinction): 吸収
  metalness: 鏡面反射
  transparency: 屈折透過
refraction: 屈折率
  metalnessは媒質の屈折率から求められるが、入射前/入射後両方の値が必要になる
  屈折率を必ず持つか、持たないなら0と仮定するなどが必要になってくる


球面ガウス関数による近似?



モデル形状はOpenSCADで確認しながら作るほうが楽かも

npm init
npm install webpack webpack-cli -D
npm install typescript ts-loader -D
npm install raw-loader -D
/*
npm install glslify glslify-import -D
npm install glslify-loader glslify-import-loader -D
npm install template-literals-loader -D
*/


WebGL系は諸々古くて性能が厳しい
  WebGPUの方がよい(Canary限定)
  Vulkanなどもあり


GLSL
ポインタが無い(in/out修飾子を使う)
関数ポインタも無い
  idで地道に分岐(あるいは*0)する
オーバーロードは可
typedefが無い
  ただしstructはいちいち付けなくていい
mat系の添え字は[列][行]の順なので注意
円周率定義なし。PI = radians(180)
キャスト演算子なし。float(num)のように書く
構造体にはデフォルトコンストラクタが設定される
  Type s = {menbers...} スタイルは利用できない


GLSLのテンプレートを別ファイルで保持、TypeScriptにテンプレートリテラルとしてimport
  template-literals-loader
  raw-loaderでtextとして読んでtemplate-literalとして評価
GLSLのプリプロセッサも利用できる
  #define FUNC_id(func, id, args) (func_##id args)

GLSLを複数のファイルに分割する
  glslify, glslify-import, glslify-loader
  use[template-literals-loader, glslify-loader] でいけるか?
