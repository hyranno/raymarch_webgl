npm run build


何をメインに据えるか
  要素のProceduralな生成
    shape
    material
    movement
  レンダリング
    ComputeShaderが使えないので無理そう
最終的に何を出力するか
  Proceduralな生成の強みは
  Blenderのモディファイアを使った表現を参考に
  鉄橋
  繰り返しの装飾
  無限長


TODO
now: refactoring
future:
  procedural material
    hyranno@ShaderToy から引っ張ってくる
    normal, metalness, specular, diffuse 等パラメータの揺れ
      normalの揺れはマイクロファセットの分布関数で既にある程度考慮されている
    Fractional Brownian Motion
  Drawable同士のUnion,SmoothUnion
  いろいろ動かす
    時間依存shape, material
      時間依存のパラメータを計算後にuniformとして渡す方がいいか
    Inverse Kinematics
soooooon:
  jest-webgl-canvas-mock
  曲率近似AmbientSelfOcclusion
  曲率依存の汚れマテリアル
  physics based rendering (material)
  L-System?
    TypeScript側で再帰し、GLSL側には単にUnionなどとして渡す?
  面光源
    photon.ray.start が random_uniform に従う?
  glslify-loader
  template-literals-loader
  (webasm + spir-v) へのコンパイル
    LLVM-SPIRV-BackendがKhronosから出てる
    Rust-gpuでやりたいな
  ComputeShader
    Monte-carlo ray-trace
    Photon-mapping
    Screen-space effects
    波のGPUシミュレーション


GPUの性能が厳しい
  Intel UHD Graphics 620
  Intel Iris Xe Graphics
    gl driver message (opengl, performance, gl_close_path_nv, high): gpu stall due to readpixels
  CPU内蔵のグラフィック機能でレイマーチングを回すのがそもそも厳しいか
  WebGL conformance test
    https://www.khronos.org/registry/webgl/sdk/tests/webgl-conformance-tests.html?version=2.0.1


InigoQuilez: FBM detail in SDFs
  ランダムなサイズのsphere?を各座標に生成
    Sphereの原点はround(直交座標)でない方がよいか(正四面体の座標系など)
    Sphereの半径が従う確率分布?
      指数分布
        Unionのみ/Subtractionのみの場合に有効そう
      正規分布
        平均0の正規分布にしてUnionとSubtractionに分けられないか?
        UniSphere...ru=max(r,0), SubSphere...rs=(max(-r,0))
  SmoothIntersection(Hollowed(original), spheres) で球の取り出し
    SmoothBooleanOp そのままではなく手を加えてもよい
    変位の大きい部分の形状を調整
  SmoothUnion / SmoothSubtraction で対象と結合
    変位の小さい部分の形状を調整
  新たな対象としてループ
周期的に表面から離れた場所に球が生える
Subtractionの方はBoundingShapeを付けられる



球状のウェーブレット(のようなもの)
  3次関数v(r)を使って、v(step(r))
  v(0) = 1, dv_dr(0) = 0
  v(1) = 0, dv_dr(1) = 0
  球積分(v(r), 0<=r<=1) = 0
    円積分の方がいい?


shapeFBMのShapesRand
  距離関数がおかしくなってそう(無限ループバグの元)


findNearestDrawable
rayCastのl + obj_distance < EPS となるものは無視?

オブジェクトの重なり
オブジェクトが重なる位置において、どのオブジェクトの情報を返すか
優先度を設定し、自動的にDefferenceを行う?

findMedium
物体から出る(dot(ray.direction,法線)>0)時に使う
距離が負かつ最も大きいもの(絶対値が小さい)ものを媒質とする
今まで居た物質は無視
物体に入る(dot(ray.direction,法線<0))ときは当たった面のものを使えばよい

ray-marching
  反射/屈折後に2*EPSだけ進める?

屈折光のray-marchingどうする?
  距離関数が負のとき
    陰面消去の判定を反転
    距離の符号を反転
  反射するか屈折するかを乱数で



パストレーシング、計算誤差の影響が結構大きい(ray.directionの精度?)


rgb<->hsv

右手系の座標を扱う: cross(x,y) = z

環境光(ambient)
  色も強度も一定
拡散反射(diffuse, ランバート反射)
  photon入射ベクトルと面の法線で決まる
  視線は関係なし
鏡面反射(specular, 鏡面ハイライト-ガウス分布)
  視線と入射ベクトルと面の法線で決まる
  強度変化のみ、色の変化なし

入射光エネルギー = absorption + (1-drain)( metalness + (1-metalness)( (1-transparency) + transparency ) )
  absorption(extinction): 吸収
  metalness: 鏡面反射
  transparency: 屈折透過
refraction: 屈折率
  metalnessは媒質の屈折率から求められるが、入射前/入射後両方の値が必要になる
  屈折率を必ず持つか、持たないなら0と仮定するなどが必要になってくる


球面ガウス関数による近似?



モデル形状はOpenSCADで確認しながら作るほうが楽かも

npm init
npm install webpack webpack-cli -D
npm install typescript ts-loader -D
npm install raw-loader -D
/*
npm install glslify glslify-import -D
npm install glslify-loader glslify-import-loader -D
npm install template-literals-loader -D
*/


WebGL系は諸々古くて性能が厳しい
  WebGPUの方がよい(Canary限定)
  Vulkanなどもあり


TypeScriptのコンストラクタ
  コンストラクタ引数にアクセス修飾子を付けると
    this.foo = foo を書かなくていい
    メンバ宣言も省略できる
  メンバ宣言省略はメンバ確認に難が出るのでしない方がよいのでは

Glslポリモーフィズム
  GlEntityでやる
  glslにラッパー関数を持たずにマクロで実関数に書き換えるほうが速いか？
    インライン展開してくれるならこの配慮は不要だが

GLSL
ポインタが無い(in/out修飾子を使う)
関数ポインタも無い
  idで地道に分岐(あるいは*0)する
オーバーロードは可
typedefが無い
  ただしstructはいちいち付けなくていい
mat系の添え字は[列][行]の順なので注意
円周率定義なし。PI = radians(180)
キャスト演算子なし。float(num)のように書く
構造体にはデフォルトコンストラクタが設定される
  Type s = {menbers...} スタイルは利用できない
整数は32bitまで


GLSLのテンプレートを別ファイルで保持、TypeScriptにテンプレートリテラルとしてimport
  template-literals-loader
  raw-loaderでtextとして読んでtemplate-literalとして評価
GLSLのプリプロセッサも利用できる
  #define FUNC_id(func, id, args) (func_##id args)

GLSLを複数のファイルに分割する
  glslify, glslify-import, glslify-loader
  use[template-literals-loader, glslify-loader] でいけるか?
